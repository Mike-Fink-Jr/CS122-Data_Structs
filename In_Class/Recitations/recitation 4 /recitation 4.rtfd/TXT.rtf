{\rtf1\ansi\ansicpg1252\cocoartf1344\cocoasubrtf720
{\fonttbl\f0\fswiss\fcharset0 ArialMT;\f1\fmodern\fcharset0 Courier;\f2\fnil\fcharset0 HelveticaNeue;
}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;\red109\green109\blue109;\red38\green38\blue38;
\red255\green255\blue255;\red23\green47\blue137;}
\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\deftab720

\itap1\trowd \taflags0 \trgaph108\trleft-108 \trbrdrt\brdrnil \trbrdrl\brdrnil \trbrdrt\brdrnil \trbrdrr\brdrnil 
\clvertalc \clshdrawnil \clwWidth220\clftsWidth3 \clmart10 \clmarl10 \clmarb10 \clmarr10 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadt20 \clpadl20 \clpadb20 \clpadr20 \gaph\cellx4320
\clvertalc \clshdrawnil \clwWidth5380\clftsWidth3 \clmart10 \clmarl10 \clmarb10 \clmarr10 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadt20 \clpadl20 \clpadb20 \clpadr20 \gaph\cellx8640
\pard\intbl\itap1\pardeftab720\sl256

\f0\fs26 \cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 \cell 
\pard\intbl\itap1\pardeftab720\sl256\qr
\cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \pard\intbl\itap1\pardeftab720\sl256\qr
\cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \cell \lastrow\row
\pard\pardeftab720\qc

\b \cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \
\pard\pardeftab720

\b0 \cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \
\
\
\pard\pardeftab720

\fs22 \cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \

\itap1\trowd \taflags0 \trgaph108\trleft-108 \trbrdrt\brdrnil \trbrdrl\brdrnil \trbrdrt\brdrnil \trbrdrr\brdrnil 
\clvertalc \clshdrawnil \clwWidth5880\clftsWidth3 \clmart10 \clmarl10 \clmarb10 \clmarr10 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadt20 \clpadl20 \clpadb20 \clpadr20 \gaph\cellx8640
\pard\intbl\itap1\pardeftab720\qc

\fs26 \cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \cell \lastrow\row
\pard\pardeftab720
\cf4 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec4 \
\
Submitted by FINK, MICHAEL (MJF5614) on 2/9/2015 11:59:46 AM\
\

\itap1\trowd \taflags0 \trgaph108\trleft-108 \trbrdrt\brdrs\brdrw20\brdrcf3 \trbrdrl\brdrs\brdrw20\brdrcf3 \trbrdrr\brdrs\brdrw20\brdrcf3 
\clvertalt \clshdrawnil \clwWidth1980\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadt80 \clpadl80 \clpadb80 \clpadr80 \gaph\cellx4320
\clvertalc \clshdrawnil \clwWidth900\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadt80 \clpadl80 \clpadb80 \clpadr80 \gaph\cellx8640
\pard\intbl\itap1\pardeftab720

\b \cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Points Awarded
\b0 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \cell 
\pard\intbl\itap1\pardeftab720\qr

\b \cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 36.50
\b0 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \cell \row

\itap1\trowd \taflags0 \trgaph108\trleft-108 \trbrdrl\brdrs\brdrw20\brdrcf3 \trbrdrr\brdrs\brdrw20\brdrcf3 
\clvertalt \clshdrawnil \clwWidth1980\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadt80 \clpadl80 \clpadb80 \clpadr80 \gaph\cellx4320
\clvertalc \clshdrawnil \clwWidth900\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadt80 \clpadl80 \clpadb80 \clpadr80 \gaph\cellx8640
\pard\intbl\itap1\pardeftab720

\b \cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 Points Missed
\b0 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \cell 
\pard\intbl\itap1\pardeftab720\qr

\b \cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 -16.50
\b0 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \cell \row

\itap1\trowd \taflags0 \trgaph108\trleft-108 \trbrdrl\brdrs\brdrw20\brdrcf3 \trbrdrb\brdrs\brdrw20\brdrcf3 \trbrdrr\brdrs\brdrw20\brdrcf3 
\clvertalt \clshdrawnil \clwWidth1980\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadt80 \clpadl80 \clpadb80 \clpadr80 \gaph\cellx4320
\clvertalc \clshdrawnil \clwWidth900\clftsWidth3 \clbrdrt\brdrs\brdrw20\brdrcf3 \clbrdrl\brdrs\brdrw20\brdrcf3 \clbrdrb\brdrs\brdrw20\brdrcf3 \clbrdrr\brdrs\brdrw20\brdrcf3 \clpadt80 \clpadl80 \clpadb80 \clpadr80 \gaph\cellx8640
\pard\intbl\itap1\pardeftab720

\b \cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 Percentage
\b0 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \cell 
\pard\intbl\itap1\pardeftab720\qr

\b \cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 182.5%
\b0 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \cell \lastrow\row
\pard\pardeftab720
\cf4 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec4 \
\
\pard\pardeftab720

\b \cf4 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 1.\
\pard\pardeftab720

\b0 \cf4 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 This week and next week will both study recursive functions from an unusual perspective. We will take working functions and rewrite them into non-recursive functions that repeat using loops. This would no doubt cause some to ask "If it ain't broke, why fix it?" Sometimes a recursive function simply is not a good use of resources and/or time.\
\pard\pardeftab720\sa256
\cf4 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 The worst offenders are functions with multiple recursion, such as the recursive implementation of the Fibonacci. They may find themselves solving the same subproblems repeatedly and continually forgetting the answers they found. The solution to find in those cases is to find the simple answers and hold onto them (usually in something like an array), so they need not be computed.\
We will focus on lesser offenders, that use single-recursion. The only real time penalty here is the extra time to call and return from a functions. The bigger penalty is the need for additional memory for recursive calls. Those would be eliminated if written as a loop.\
With the file reorganization, the program today is in the #3 folder for inclass. Compile/run the code for the existing assignment. This will allow you to know what the 'right' answers are in case they are not already evident.\
Let's take a look at the first recursive function: 
\f1 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 firstDigit
\f0 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 . What is happening to the computed result of 
\f1 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 value / 10
\f0 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 ? Be as complete as possible in your answer.\
\pard\pardeftab720

\f2\fs24 \cf2 \cb5 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 it takes away the last digit of the number and runs the function again looking if the new digit is < 10 if not it repeats again until it does happen\
\pard\pardeftab720

\f0\fs26 \cf4 \cb1 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec4 \
\
\pard\pardeftab720

\b \cf4 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 Feedback: 
\b0 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 Part of the observation is that this is claiming new memory that we really do not need.\
\
\pard\pardeftab720\qc
\cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Table for Individual Question Feedback\

\itap1\trowd \taflags0 \trgaph108\trleft-108 \trbrdrt\brdrnil \trbrdrl\brdrnil \trbrdrr\brdrnil 
\clvertalt \clshdrawnil \clwWidth1700\clftsWidth3 \clmart10 \clmarl10 \clmarb10 \clmarr10 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadt40 \clpadl40 \clpadb40 \clpadr40 \gaph\cellx2880
\clvertalt \clshdrawnil \clwWidth12460\clftsWidth3 \clmart10 \clmarl10 \clmarb10 \clmarr10 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadt40 \clpadl40 \clpadb40 \clpadr40 \gaph\cellx5760
\clvertalc \clshdrawnil \clwWidth1080\clftsWidth3 \clmart10 \clmarl10 \clmarb10 \clmarr10 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadt40 \clpadl40 \clpadb40 \clpadr40 \gaph\cellx8640
\pard\intbl\itap1\pardeftab720

\b \cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 Points Earned:\cell 
\pard\intbl\itap1\pardeftab720

\b0 \cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 1.0/1.0\cell 
\pard\intbl\itap1\pardeftab720
\cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \cell \row

\itap1\trowd \taflags0 \trgaph108\trleft-108 \trbrdrl\brdrnil \trbrdrt\brdrnil \trbrdrr\brdrnil 
\clvertalt \clshdrawnil \clwWidth1700\clftsWidth3 \clmart10 \clmarl10 \clmarb10 \clmarr10 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadt40 \clpadl40 \clpadb40 \clpadr40 \gaph\cellx2880
\clmgf \clvertalt \clshdrawnil \clwWidth13640\clftsWidth3 \clmart10 \clmarl10 \clmarb10 \clmarr10 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadt40 \clpadl40 \clpadb40 \clpadr40 \gaph\cellx5760
\clmrg \clvertalt \clshdrawnil \clwWidth13640\clftsWidth3 \clmart10 \clmarl10 \clmarb10 \clmarr10 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadt40 \clpadl40 \clpadb40 \clpadr40 \gaph\cellx8640
\pard\intbl\itap1\pardeftab720

\b \cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 Correct Answer(s):
\b0 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \cell 
\pard\intbl\itap1\pardeftab720
\cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 It is being assigned to a newly created variable (formal parameter) named 'value'. This is a distinct variable in a new memory region for the recursive function call.\cell 
\pard\intbl\itap1\cell \lastrow\row
\pard\pardeftab720
\cf4 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec4 \
\
\
\pard\pardeftab720

\b \cf4 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 2.\
\pard\pardeftab720

\b0 \cf4 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 So, we have a sort of assignment operation occurring here, followed by a need to start the function at the beginning. We could break this down into simpler steps as follows:\
\pard\pardeftab720

\f1 \cf4 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 if (value >= 10)\
    assign a quotient to a new value\
    go to the top of this code\
else\
    return value as the answer\
\pard\pardeftab720

\f0 \cf4 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 This is not exactly how the recursive function really behaves, but it does accurately describe how an answer is found.\
\pard\pardeftab720\sa256
\cf4 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 The structure of this code, however, should look like something very different and recognizable. What C++ statement most closely resembles this code structure?\
\pard\pardeftab720

\f2\fs24 \cf2 \cb5 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 while loop\
\pard\pardeftab720

\f0\fs26 \cf4 \cb1 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec4 \
\
\pard\pardeftab720

\b \cf4 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 Feedback: 
\b0 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 it is good to be able to recognize a while loop behavior when it is in disguise\
\
\pard\pardeftab720\qc
\cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Table for Individual Question Feedback\

\itap1\trowd \taflags0 \trgaph108\trleft-108 \trbrdrt\brdrnil \trbrdrl\brdrnil \trbrdrr\brdrnil 
\clvertalt \clshdrawnil \clwWidth2360\clftsWidth3 \clmart10 \clmarl10 \clmarb10 \clmarr10 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadt40 \clpadl40 \clpadb40 \clpadr40 \gaph\cellx2880
\clvertalt \clshdrawnil \clwWidth6500\clftsWidth3 \clmart10 \clmarl10 \clmarb10 \clmarr10 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadt40 \clpadl40 \clpadb40 \clpadr40 \gaph\cellx5760
\clvertalc \clshdrawnil \clwWidth520\clftsWidth3 \clmart10 \clmarl10 \clmarb10 \clmarr10 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadt40 \clpadl40 \clpadb40 \clpadr40 \gaph\cellx8640
\pard\intbl\itap1\pardeftab720

\b \cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 Points Earned:\cell 
\pard\intbl\itap1\pardeftab720

\b0 \cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 2.0/2.0\cell 
\pard\intbl\itap1\pardeftab720
\cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \cell \row

\itap1\trowd \taflags0 \trgaph108\trleft-108 \trbrdrl\brdrnil \trbrdrt\brdrnil \trbrdrr\brdrnil 
\clvertalt \clshdrawnil \clwWidth2360\clftsWidth3 \clmart10 \clmarl10 \clmarb10 \clmarr10 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadt40 \clpadl40 \clpadb40 \clpadr40 \gaph\cellx2880
\clmgf \clvertalt \clshdrawnil \clwWidth7120\clftsWidth3 \clmart10 \clmarl10 \clmarb10 \clmarr10 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadt40 \clpadl40 \clpadb40 \clpadr40 \gaph\cellx5760
\clmrg \clvertalt \clshdrawnil \clwWidth7120\clftsWidth3 \clmart10 \clmarl10 \clmarb10 \clmarr10 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadt40 \clpadl40 \clpadb40 \clpadr40 \gaph\cellx8640
\pard\intbl\itap1\pardeftab720

\b \cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 Correct Answer(s):
\b0 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \cell 
\pard\intbl\itap1\pardeftab720
\cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 the while loop; repeatedly divide until value has only one digit.\cell 
\pard\intbl\itap1\cell \lastrow\row
\pard\pardeftab720
\cf4 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec4 \
\
\
\pard\pardeftab720

\b \cf4 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 3.\
\pard\pardeftab720

\b0 \cf4 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 Assuming you found a suitable loop to use for this function, replace the recursive function behavior with a loop, and then make sure it works.\
\pard\pardeftab720\sa256
\cf4 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 The special thing about this recursive function is that it is 
\i \expnd0\expndtw0\kerning0
\outl0\strokewidth0 tail-recursive
\i0 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 . The recursive operation is the absolute last operation before it returns, so when it finally stops recursing, all it has to do is return an answer. In the same way, our loop returns as soon as it has an answer, but does not have to spend any extra time passing that answer through many return statements.\
Try the same manipulations with the second function: 
\f1 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 gcf
\f0 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 .\uc0\u8232 Consider what is happening to the actual parameters 
\f1 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 b
\f0 \expnd0\expndtw0\kerning0
\outl0\strokewidth0  and 
\f1 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 rem
\f0 \expnd0\expndtw0\kerning0
\outl0\strokewidth0  in the function call. You will also need to pay attention to the assignment operation that appears before the 
\f1 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 if
\f0 \expnd0\expndtw0\kerning0
\outl0\strokewidth0  statement. This should also work correctly when done.\
True or False? Since there were two parameters, there are exactly two assignment operations in my loop.\
\pard\pardeftab720
\cf4 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 A) True\
B) False\
\
\
\pard\pardeftab720

\b \cf4 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 Feedback: 
\b0 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 Good! We have done 2 out of 5 functions so far.\
\
\pard\pardeftab720

\fs24 \cf4 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 grade added in here is for his last recitation: unable to submit, talk to professor Christman about it, re-did it on Feb 9th. Graded by Wenjia Zhang\
\pard\pardeftab720\qc

\fs26 \cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Table for Individual Question Feedback\

\itap1\trowd \taflags0 \trgaph108\trleft-108 \trbrdrt\brdrnil \trbrdrl\brdrnil \trbrdrr\brdrnil 
\clvertalt \clshdrawnil \clwWidth2360\clftsWidth3 \clmart10 \clmarl10 \clmarb10 \clmarr10 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadt40 \clpadl40 \clpadb40 \clpadr40 \gaph\cellx2880
\clvertalt \clshdrawnil \clwWidth940\clftsWidth3 \clmart10 \clmarl10 \clmarb10 \clmarr10 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadt40 \clpadl40 \clpadb40 \clpadr40 \gaph\cellx5760
\clvertalc \clshdrawnil \clmart10 \clmarl10 \clmarb10 \clmarr10 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadt40 \clpadl40 \clpadb40 \clpadr40 \gaph\cellx8640
\pard\intbl\itap1\pardeftab720

\b \cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 Points Earned:\cell 
\pard\intbl\itap1\pardeftab720

\b0 \cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 17.0/0.0\cell 
\pard\intbl\itap1\pardeftab720
\cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \cell \row

\itap1\trowd \taflags0 \trgaph108\trleft-108 \trbrdrl\brdrnil \trbrdrt\brdrnil \trbrdrr\brdrnil 
\clvertalt \clshdrawnil \clwWidth2360\clftsWidth3 \clmart10 \clmarl10 \clmarb10 \clmarr10 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadt40 \clpadl40 \clpadb40 \clpadr40 \gaph\cellx2880
\clmgf \clvertalt \clshdrawnil \clwWidth1040\clftsWidth3 \clmart10 \clmarl10 \clmarb10 \clmarr10 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadt40 \clpadl40 \clpadb40 \clpadr40 \gaph\cellx5760
\clmrg \clvertalt \clshdrawnil \clwWidth1040\clftsWidth3 \clmart10 \clmarl10 \clmarb10 \clmarr10 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadt40 \clpadl40 \clpadb40 \clpadr40 \gaph\cellx8640
\pard\intbl\itap1\pardeftab720

\b \cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 Correct Answer(s):
\b0 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \cell 
\pard\intbl\itap1\pardeftab720
\cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 False\cell 
\pard\intbl\itap1\cell \lastrow\row
\pard\pardeftab720
\cf4 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec4 \
\
\
\pard\pardeftab720

\b \cf4 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 4.\
\pard\pardeftab720

\b0 \cf4 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 The third function 
\f1 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 bsearch
\f0 \expnd0\expndtw0\kerning0
\outl0\strokewidth0  is also tail-recursive, but it has a couple extra twists:\
-- the non-recursive cases come before the recursive cases, instead of the other way around\
-- there are two recursive cases and two non-recursive cases, instead of just one of each\
\pard\pardeftab720\sa256
\cf4 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 First things first:\uc0\u8232 The repetition will be addressed in a loop (NOT two loops!)\u8232 what would be a good loop condition for this loop?\u8232 It must be complete in itself. Using 
\f1 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 break
\f0 \expnd0\expndtw0\kerning0
\outl0\strokewidth0  to exit a loop is forbidden in this course.\
\pard\pardeftab720

\f2\fs24 \cf2 \cb5 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 do\{\} while (list[mid] != value && left<=right);\
\pard\pardeftab720

\f0\fs26 \cf4 \cb1 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec4 \
\
\pard\pardeftab720

\b \cf4 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 Feedback: 
\b0 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 It is good to know you can use your compound expressions effectively\
\
\pard\pardeftab720\qc
\cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Table for Individual Question Feedback\

\itap1\trowd \taflags0 \trgaph108\trleft-108 \trbrdrt\brdrnil \trbrdrl\brdrnil \trbrdrr\brdrnil 
\clvertalt \clshdrawnil \clwWidth2360\clftsWidth3 \clmart10 \clmarl10 \clmarb10 \clmarr10 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadt40 \clpadl40 \clpadb40 \clpadr40 \gaph\cellx2880
\clvertalt \clshdrawnil \clwWidth8860\clftsWidth3 \clmart10 \clmarl10 \clmarb10 \clmarr10 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadt40 \clpadl40 \clpadb40 \clpadr40 \gaph\cellx5760
\clvertalc \clshdrawnil \clwWidth740\clftsWidth3 \clmart10 \clmarl10 \clmarb10 \clmarr10 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadt40 \clpadl40 \clpadb40 \clpadr40 \gaph\cellx8640
\pard\intbl\itap1\pardeftab720

\b \cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 Points Earned:\cell 
\pard\intbl\itap1\pardeftab720

\b0 \cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 3.0/3.0\cell 
\pard\intbl\itap1\pardeftab720
\cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \cell \row

\itap1\trowd \taflags0 \trgaph108\trleft-108 \trbrdrl\brdrnil \trbrdrt\brdrnil \trbrdrr\brdrnil 
\clvertalt \clshdrawnil \clwWidth2360\clftsWidth3 \clmart10 \clmarl10 \clmarb10 \clmarr10 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadt40 \clpadl40 \clpadb40 \clpadr40 \gaph\cellx2880
\clmgf \clvertalt \clshdrawnil \clwWidth9700\clftsWidth3 \clmart10 \clmarl10 \clmarb10 \clmarr10 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadt40 \clpadl40 \clpadb40 \clpadr40 \gaph\cellx5760
\clmrg \clvertalt \clshdrawnil \clwWidth9700\clftsWidth3 \clmart10 \clmarl10 \clmarb10 \clmarr10 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadt40 \clpadl40 \clpadb40 \clpadr40 \gaph\cellx8640
\pard\intbl\itap1\pardeftab720

\b \cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 Correct Answer(s):
\b0 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \cell 
\pard\intbl\itap1\pardeftab720
\cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 This requires a compound test: two reasons to leave, so two requirements to repeat.\
\pard\intbl\itap1\pardeftab720

\f1 \cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 !( left > right || value == list[mid] )\
OR, equivalently,\
left <= right && value != list[mid]\cell 
\pard\intbl\itap1\cell \lastrow\row
\pard\pardeftab720

\f0 \cf4 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec4 \
\
\
\pard\pardeftab720

\b \cf4 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 5.\
\pard\pardeftab720

\b0 \cf4 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 Now that the loop has been addressed, the rest of this should be rather simple. We have two alternatives when repeating, and two alternatives when no longer repeating.\
\pard\pardeftab720\sa256
\cf4 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 Find a good simple way to handle them, and complete the function accordingly.\
(By the way, this function was a CMPSC 121 final exam question in the Fall 2013 semester. I hope you are comfortable enough with recursion and the binary search algorithm to be able to write code like this.)\
Actually, there is one more tweak I would make to this function. The recursive implementation required two parameters 
\f1 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 left
\f0 \expnd0\expndtw0\kerning0
\outl0\strokewidth0  and 
\f1 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 right
\f0 \expnd0\expndtw0\kerning0
\outl0\strokewidth0  to solve its problem. This might seem an odd requirement to a function caller. He might think it would make sense to only need to supply the size of the array (10 in this case). Modify the function accordingly, both here, and in the caller, and do not forget the function prototype at the very top.\
Assuming you successfully made that function work correctly, let us move on to the next.\
I would not call this 
\f1 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 factorial
\f0 \expnd0\expndtw0\kerning0
\outl0\strokewidth0  function tail-recursive. The textbook probably would. Recursion does occur in the last statement executed, but what is different about the return value here as compared to the earlier functions today?\
\pard\pardeftab720

\f2\fs24 \cf2 \cb5 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 the return has the recursion in it and it is being multiplied\
\pard\pardeftab720

\f0\fs26 \cf4 \cb1 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec4 \
\
\pard\pardeftab720

\b \cf4 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 Feedback: 
\b0 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 You may need to be more comfortable with the behavior of recursive functions.\
\
\pard\pardeftab720\qc
\cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Table for Individual Question Feedback\

\itap1\trowd \taflags0 \trgaph108\trleft-108 \trbrdrt\brdrnil \trbrdrl\brdrnil \trbrdrr\brdrnil 
\clvertalt \clshdrawnil \clwWidth1680\clftsWidth3 \clmart10 \clmarl10 \clmarb10 \clmarr10 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadt40 \clpadl40 \clpadb40 \clpadr40 \gaph\cellx2880
\clvertalt \clshdrawnil \clwWidth12480\clftsWidth3 \clmart10 \clmarl10 \clmarb10 \clmarr10 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadt40 \clpadl40 \clpadb40 \clpadr40 \gaph\cellx5760
\clvertalc \clshdrawnil \clwWidth1080\clftsWidth3 \clmart10 \clmarl10 \clmarb10 \clmarr10 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadt40 \clpadl40 \clpadb40 \clpadr40 \gaph\cellx8640
\pard\intbl\itap1\pardeftab720

\b \cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 Points Earned:\cell 
\pard\intbl\itap1\pardeftab720

\b0 \cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 0.5/1.0\cell 
\pard\intbl\itap1\pardeftab720
\cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \cell \row

\itap1\trowd \taflags0 \trgaph108\trleft-108 \trbrdrl\brdrnil \trbrdrt\brdrnil \trbrdrr\brdrnil 
\clvertalt \clshdrawnil \clwWidth1680\clftsWidth3 \clmart10 \clmarl10 \clmarb10 \clmarr10 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadt40 \clpadl40 \clpadb40 \clpadr40 \gaph\cellx2880
\clmgf \clvertalt \clshdrawnil \clwWidth13660\clftsWidth3 \clmart10 \clmarl10 \clmarb10 \clmarr10 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadt40 \clpadl40 \clpadb40 \clpadr40 \gaph\cellx5760
\clmrg \clvertalt \clshdrawnil \clwWidth13660\clftsWidth3 \clmart10 \clmarl10 \clmarb10 \clmarr10 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadt40 \clpadl40 \clpadb40 \clpadr40 \gaph\cellx8640
\pard\intbl\itap1\pardeftab720

\b \cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 Correct Answer(s):
\b0 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \cell 
\pard\intbl\itap1\pardeftab720
\cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 The return value from the base case (1) is not the final answer. Instead, there are a series of multiplications that occur After this starts to return from the base case!\cell 
\pard\intbl\itap1\cell \lastrow\row
\pard\pardeftab720
\cf4 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec4 \
\
\
\pard\pardeftab720

\b \cf4 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 6.\
\pard\pardeftab720

\b0 \cf4 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 The issue here is that there is a multiplication step occurring after the recursive step returns. We cannot simply claim that the return value from the base case is the final answer. Also, we cannot just multiply by 
\f1 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 n
\f0 \expnd0\expndtw0\kerning0
\outl0\strokewidth0  once the loop ends.\
\pard\pardeftab720\sa256
\cf4 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 Why not?\
\pard\pardeftab720

\f2\fs24 \cf2 \cb5 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 because you have to multiply the last recursive call by the one before and so on. (this was a piece of crap question)\
\pard\pardeftab720

\f0\fs26 \cf4 \cb1 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec4 \
\
\pard\pardeftab720

\b \cf4 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 Feedback: 
\b0 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 No problem so far, right?\
\
\pard\pardeftab720\qc
\cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Table for Individual Question Feedback\

\itap1\trowd \taflags0 \trgaph108\trleft-108 \trbrdrt\brdrnil \trbrdrl\brdrnil \trbrdrr\brdrnil 
\clvertalt \clshdrawnil \clwWidth2360\clftsWidth3 \clmart10 \clmarl10 \clmarb10 \clmarr10 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadt40 \clpadl40 \clpadb40 \clpadr40 \gaph\cellx2880
\clvertalt \clshdrawnil \clwWidth9780\clftsWidth3 \clmart10 \clmarl10 \clmarb10 \clmarr10 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadt40 \clpadl40 \clpadb40 \clpadr40 \gaph\cellx5760
\clvertalc \clshdrawnil \clwWidth820\clftsWidth3 \clmart10 \clmarl10 \clmarb10 \clmarr10 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadt40 \clpadl40 \clpadb40 \clpadr40 \gaph\cellx8640
\pard\intbl\itap1\pardeftab720

\b \cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 Points Earned:\cell 
\pard\intbl\itap1\pardeftab720

\b0 \cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 1.0/1.0\cell 
\pard\intbl\itap1\pardeftab720
\cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \cell \row

\itap1\trowd \taflags0 \trgaph108\trleft-108 \trbrdrl\brdrnil \trbrdrt\brdrnil \trbrdrr\brdrnil 
\clvertalt \clshdrawnil \clwWidth2360\clftsWidth3 \clmart10 \clmarl10 \clmarb10 \clmarr10 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadt40 \clpadl40 \clpadb40 \clpadr40 \gaph\cellx2880
\clmgf \clvertalt \clshdrawnil \clwWidth10700\clftsWidth3 \clmart10 \clmarl10 \clmarb10 \clmarr10 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadt40 \clpadl40 \clpadb40 \clpadr40 \gaph\cellx5760
\clmrg \clvertalt \clshdrawnil \clwWidth10700\clftsWidth3 \clmart10 \clmarl10 \clmarb10 \clmarr10 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadt40 \clpadl40 \clpadb40 \clpadr40 \gaph\cellx8640
\pard\intbl\itap1\pardeftab720

\b \cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 Correct Answer(s):
\b0 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \cell 
\pard\intbl\itap1\pardeftab720
\cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 Because when our loop ends, n is no longer what it started at. That result would be no better!\cell 
\pard\intbl\itap1\cell \lastrow\row
\pard\pardeftab720
\cf4 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec4 \
\
\
\pard\pardeftab720

\b \cf4 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 7.\
\pard\pardeftab720

\b0 \cf4 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 Fortunately, we have an easy fix for this. Instead of postponing the multiplication until the end, let us do it before we recurse. This would more closely resemble what I call tail recursion.\
\pard\pardeftab720\sa256
\cf4 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 If you wished an explicit intermediate step, pretend that this function instead had two parameters: 
\f1 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 n
\f0 \expnd0\expndtw0\kerning0
\outl0\strokewidth0  and 
\f1 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 product
\f0 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 . What would our tail-recursive call look like?\
\
\pard\pardeftab720

\f1 \cf4 \expnd0\expndtw0\kerning0
\outl0\strokewidth0     return factorial( n-1, 
\f2\fs24 \cf2 \cb5 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 n*product
\f1\fs26 \cf4 \cb1 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec4  );\
\pard\pardeftab720

\f0 \cf4 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \
\
\pard\pardeftab720\qc
\cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Table for Individual Question Feedback\

\itap1\trowd \taflags0 \trgaph108\trleft-108 \trbrdrt\brdrnil \trbrdrl\brdrnil \trbrdrr\brdrnil 
\clvertalt \clshdrawnil \clwWidth2360\clftsWidth3 \clmart10 \clmarl10 \clmarb10 \clmarr10 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadt40 \clpadl40 \clpadb40 \clpadr40 \gaph\cellx2880
\clvertalt \clshdrawnil \clwWidth4720\clftsWidth3 \clmart10 \clmarl10 \clmarb10 \clmarr10 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadt40 \clpadl40 \clpadb40 \clpadr40 \gaph\cellx5760
\clvertalc \clshdrawnil \clwWidth360\clftsWidth3 \clmart10 \clmarl10 \clmarb10 \clmarr10 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadt40 \clpadl40 \clpadb40 \clpadr40 \gaph\cellx8640
\pard\intbl\itap1\pardeftab720

\b \cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 Points Earned:\cell 
\pard\intbl\itap1\pardeftab720

\b0 \cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 1.0/1.0\cell 
\pard\intbl\itap1\pardeftab720
\cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \cell \row

\itap1\trowd \taflags0 \trgaph108\trleft-108 \trbrdrl\brdrnil \trbrdrt\brdrnil \trbrdrr\brdrnil 
\clvertalt \clshdrawnil \clwWidth2360\clftsWidth3 \clmart10 \clmarl10 \clmarb10 \clmarr10 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadt40 \clpadl40 \clpadb40 \clpadr40 \gaph\cellx2880
\clmgf \clvertalt \clshdrawnil \clwWidth5180\clftsWidth3 \clmart10 \clmarl10 \clmarb10 \clmarr10 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadt40 \clpadl40 \clpadb40 \clpadr40 \gaph\cellx5760
\clmrg \clvertalt \clshdrawnil \clwWidth5180\clftsWidth3 \clmart10 \clmarl10 \clmarb10 \clmarr10 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadt40 \clpadl40 \clpadb40 \clpadr40 \gaph\cellx8640
\pard\intbl\itap1\pardeftab720

\b \cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 Correct Answer(s):
\b0 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \cell 
\pard\intbl\itap1\pardeftab720
\cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 n * product, n*product, product * n, product*n\cell 
\pard\intbl\itap1\cell \lastrow\row
\pard\pardeftab720
\cf4 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec4 \
\
\
\pard\pardeftab720

\b \cf4 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 8.\
\pard\pardeftab720

\b0 \cf4 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 Take advantage of the trick suggested in the last question to rewrite factorial as a non-recursive function. The variable updates must still closely resemble how the parameter was being assigned.\
\pard\pardeftab720\sa256
\cf4 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 Then do the same thing with the given 
\f1 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 power
\f0 \expnd0\expndtw0\kerning0
\outl0\strokewidth0  function (assuming time permits).\
When you are done for today, you can upload your .cpp file along using the button below.\
Next week: a couple functions that could be written to be last-line recursive, but are very much NOT tail-recursive!\
\pard\pardeftab720
\cf4 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \
\pard\pardeftab720
{\field{\*\fldinst{HYPERLINK "https://cms.psu.edu/Section/Assessment/Delivery/OfflineItemDownload.aspx?deliveredId=d89a86c0-4d50-4583-a264-283358eebc0d&file=recitation4Source.cpp"}}{\fldrslt \cf6 \expnd0\expndtw0\kerning0
\ul \ulc6 \outl0\strokewidth0 \strokec6 recitation4Source.cpp}}\
\
\
\pard\pardeftab720\qc
\cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Table for Individual Question Feedback\

\itap1\trowd \taflags0 \trgaph108\trleft-108 \trbrdrt\brdrnil \trbrdrl\brdrnil \trbrdrt\brdrnil \trbrdrr\brdrnil 
\clvertalt \clshdrawnil \clwWidth1840\clftsWidth3 \clmart10 \clmarl10 \clmarb10 \clmarr10 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadt40 \clpadl40 \clpadb40 \clpadr40 \gaph\cellx2880
\clvertalt \clshdrawnil \clwWidth1060\clftsWidth3 \clmart10 \clmarl10 \clmarb10 \clmarr10 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadt40 \clpadl40 \clpadb40 \clpadr40 \gaph\cellx5760
\clvertalc \clshdrawnil \clmart10 \clmarl10 \clmarb10 \clmarr10 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadt40 \clpadl40 \clpadb40 \clpadr40 \gaph\cellx8640
\pard\intbl\itap1\pardeftab720

\b \cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 Points Earned:\cell 
\pard\intbl\itap1\pardeftab720

\b0 \cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 11.0/11.0\cell 
\pard\intbl\itap1\pardeftab720
\cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \cell \lastrow\row
\pard\pardeftab720
\cf4 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec4 \
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
}